<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>IKEA Layout 3D Tour</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0b1120;
      font-family: Arial, sans-serif;
      color: #e5e7eb;
    }
    #ui {
      position: absolute;
      top: 15px;
      left: 15px;
      z-index: 10;
      background: rgba(15, 23, 42, 0.85);
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid #1f2937;
    }
    #ui h2 {
      margin: 0 0 8px;
      font-size: 16px;
    }
    #ui button {
      padding: 8px 14px;
      border: none;
      border-radius: 8px;
      background: #0051ba;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }
    #ui small {
      display: block;
      margin-top: 6px;
      font-size: 11px;
      color: #9ca3af;
    }
  </style>
</head>
<body>
  <div id="ui">
    <h2>IKEA Layout 3D Tour</h2>
    <button onclick="startTour()">Start Guided Path</button>
    <small>Camera will follow the store route automatically.</small>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';
    import { TextGeometry } from 'https://unpkg.com/three@0.155.0/examples/jsm/geometries/TextGeometry.js';
    import { FontLoader } from 'https://unpkg.com/three@0.155.0/examples/jsm/loaders/FontLoader.js';

    let scene, camera, renderer;
    let tourPoints = [];
    let touring = false;
    let tourStartTime = 0;
    const tourSegmentDuration = 2200;

    const fontLoader = new FontLoader();

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0051ba); // IKEA blue

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
      );
      camera.position.set(0, 2, 40);
      camera.lookAt(0, 2, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const ambient = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambient);

      const spot = new THREE.SpotLight(0xffffff, 1.4, 200, Math.PI / 4, 0.5);
      spot.position.set(0, 30, 10);
      spot.castShadow = true;
      scene.add(spot);

      const floorGeom = new THREE.PlaneGeometry(60, 90);
      const floorMat = new THREE.MeshStandardMaterial({
        color: 0x0f172a,
        roughness: 0.8,
      });
      const floor = new THREE.Mesh(floorGeom, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      createWalls();
      createPathLine();
      createZonesAndTourPoints();

      window.addEventListener('resize', onWindowResize);
    }

    function createWalls() {
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0x0b1120,
        roughness: 0.7,
      });

      const addWall = (x, y, z, w, h, d) => {
        const geom = new THREE.BoxGeometry(w, h, d);
        const mesh = new THREE.Mesh(geom, wallMat);
        mesh.position.set(x, y, z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);
      };

      const h = 3;
      // Outer rectangle
      addWall(0, h / 2, -45, 60, h, 1);
      addWall(0, h / 2, 45, 60, h, 1);
      addWall(-30, h / 2, 0, 1, h, 90);
      addWall(30, h / 2, 0, 1, h, 90);

      // Internal partitions (rough match to IKEA map)
      addWall(-15, h / 2, 25, 1, h, 30);
      addWall(10, h / 2, 20, 1, h, 40);
      addWall(-10, h / 2, -10, 1, h, 40);
      addWall(15, h / 2, -15, 1, h, 25);
      addWall(0, h / 2, -5, 40, h, 1);
    }

    function createPathLine() {
      const points = [
        new THREE.Vector3(0, 0.02, 40),
        new THREE.Vector3(-15, 0.02, 30),
        new THREE.Vector3(-5, 0.02, 20),
        new THREE.Vector3(15, 0.02, 25),
        new THREE.Vector3(15, 0.02, 10),
        new THREE.Vector3(-5, 0.02, 10),
        new THREE.Vector3(-10, 0.02, -10),
        new THREE.Vector3(-15, 0.02, -25),
        new THREE.Vector3(10, 0.02, -25),
        new THREE.Vector3(0, 0.02, -40),
      ];

      const pathGeom = new THREE.BufferGeometry().setFromPoints(points);
      const pathMat = new THREE.LineDashedMaterial({
        color: 0xffffff,
        dashSize: 1,
        gapSize: 0.6,
        linewidth: 2,
      });

      const line = new THREE.Line(pathGeom, pathMat);
      line.computeLineDistances();
      scene.add(line);
    }

    function createZonesAndTourPoints() {
      fontLoader.load(
        'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',
        (font) => {
          const createLabel = (text, pos, color = 0xfacc15) => {
            const geom = new TextGeometry(text, {
              font,
              size: 1.1,
              height: 0.2,
            });
            const mat = new THREE.MeshStandardMaterial({ color });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.castShadow = true;
            scene.add(mesh);
          };

          createLabel('Living rooms', { x: -15, y: 2.5, z: 30 });
          createLabel('Work spaces', { x: -5, y: 2.5, z: 20 });
          createLabel('Kitchens', { x: 15, y: 2.5, z: 25 });
          createLabel('Dining', { x: 15, y: 2.5, z: 10 });
          createLabel('Living room storage', { x: -8, y: 2.5, z: 10 });
          createLabel('Children\'s IKEA', { x: 10, y: 2.5, z: -5 });
          createLabel('Bedroom storage', { x: -10, y: 2.5, z: -10 });
          createLabel('Bedrooms', { x: -15, y: 2.5, z: -25 });
          createLabel('Market hall', { x: 10, y: 2.5, z: -25 });
          createLabel('Restaurant & Cafe', { x: 0, y: 2.5, z: -40 });

          tourPoints = [
            { pos: new THREE.Vector3(0, 2, 40),  look: new THREE.Vector3(0, 2, 30) },
            { pos: new THREE.Vector3(-15, 2, 32), look: new THREE.Vector3(-15, 2, 28) },
            { pos: new THREE.Vector3(-5, 2, 22),  look: new THREE.Vector3(-5, 2, 18) },
            { pos: new THREE.Vector3(15, 2, 27),  look: new THREE.Vector3(15, 2, 23) },
            { pos: new THREE.Vector3(15, 2, 12),  look: new THREE.Vector3(15, 2, 8) },
            { pos: new THREE.Vector3(-8, 2, 12),  look: new THREE.Vector3(-8, 2, 8) },
            { pos: new THREE.Vector3(-10, 2, -8), look: new THREE.Vector3(-10, 2, -12) },
            { pos: new THREE.Vector3(-15, 2, -23),look: new THREE.Vector3(-15, 2, -27) },
            { pos: new THREE.Vector3(10, 2, -23), look: new THREE.Vector3(10, 2, -27) },
            { pos: new THREE.Vector3(0, 2, -38),  look: new THREE.Vector3(0, 2, -42) },
          ];
        }
      );
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      if (touring && tourPoints.length > 1) {
        const now = performance.now();
        const total = tourSegmentDuration * (tourPoints.length - 1);
        const segmentTime = now - tourStartTime;

        if (segmentTime >= total) {
          touring = false;
        } else {
          const segIndex = Math.floor(segmentTime / tourSegmentDuration);
          const t = (segmentTime % tourSegmentDuration) / tourSegmentDuration;

          const current = tourPoints[segIndex];
          const next = tourPoints[segIndex + 1];

          camera.position.lerpVectors(current.pos, next.pos, t);
          const look = new THREE.Vector3().lerpVectors(current.look, next.look, t);
          camera.lookAt(look);
        }
      }

      renderer.render(scene, camera);
    }

    // make startTour visible to the button
    function startTourInternal() {
      if (!tourPoints.length) return;
      touring = true;
      tourStartTime = performance.now();
      camera.position.copy(tourPoints[0].pos);
      camera.lookAt(tourPoints[0].look);
    }
    window.startTour = startTourInternal;
  </script>
</body>
</html>
