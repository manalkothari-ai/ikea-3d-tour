<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>IKEA Store 3D Tour</title>
<style>
body{margin:0;font-family:Arial,sans-serif;background:#f5f5f5;}
.header{background:#0058a3;color:white;padding:20px 40px;display:flex;justify-content:space-between;align-items:center;}
.logo{font-size:2rem;font-weight:900;letter-spacing:2px;}
.info h2{font-size:1.2rem;margin:0;}
.container{max-width:1200px;margin:30px auto;padding:0 20px;}
#scene{width:100%;height:600px;background:#e8f4f8;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,0.15);position:relative;}
.controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:15px;margin-top:20px;background:white;padding:20px;border-radius:8px;}
.ctrl{padding:15px;background:#f9f9f9;border-radius:6px;}
.ctrl h4{margin:0 0 8px;color:#0058a3;}
.legend{margin-top:20px;background:white;padding:20px;border-radius:8px;}
.legend h3{color:#0058a3;margin-top:0;}
.leg-item{display:flex;align-items:center;gap:10px;margin:8px 0;}
.color{width:30px;height:30px;border-radius:4px;}
.overlay{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:white;padding:30px;border-radius:8px;box-shadow:0 12px 40px rgba(0,0,0,0.4);display:none;z-index:1000;max-width:400px;border-top:4px solid #ffda1a;}
.overlay h3{color:#0058a3;margin:0 0 15px;}
.overlay button{background:#0058a3;color:white;border:none;padding:10px 24px;border-radius:4px;cursor:pointer;margin-top:15px;}
.backdrop{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);display:none;z-index:999;}
</style>
</head>
<body>

<div class="header">
  <div class="logo">IKEA</div>
  <div class="info"><h2>3D Store Layout Presentation</h2></div>
</div>

<div class="container">
  <div id="scene"></div>
  
  <div class="controls">
    <div class="ctrl"><h4>üéÆ Move</h4>W/A/S/D keys<br>Shift = faster</div>
    <div class="ctrl"><h4>üëÅÔ∏è Look</h4>Drag mouse<br>Scroll to zoom</div>
    <div class="ctrl"><h4>‚ÑπÔ∏è Info</h4>Click blue signs<br>Click yellow dots</div>
    <div class="ctrl"><h4>üö∂ Auto Tour</h4>Press T key<br>Automatic walkthrough</div>
    <div class="ctrl"><h4>üîÑ Reset</h4>Press Space bar<br>Return to entrance</div>
  </div>

  <div class="legend">
    <h3>Store Sections</h3>
    <div class="leg-item"><div class="color" style="background:#0058a3"></div><strong>Entrance/Exit</strong> - Customer entry, info desk</div>
    <div class="leg-item"><div class="color" style="background:#d4a373"></div><strong>Showroom</strong> - Living room, bedroom displays</div>
    <div class="leg-item"><div class="color" style="background:#ffffff;border:1px solid #ddd"></div><strong>Marketplace</strong> - Accessories, small items</div>
    <div class="leg-item"><div class="color" style="background:#8b7355"></div><strong>Warehouse</strong> - Self-service pickup</div>
    <div class="leg-item"><div class="color" style="background:#ffda1a"></div><strong>Hotspots</strong> - Process information points</div>
  </div>
</div>

<div class="backdrop" id="backdrop"></div>
<div class="overlay" id="overlay">
  <h3 id="title">Info</h3>
  <p id="text">Details here</p>
  <button onclick="closeInfo()">Close</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const wrap=document.getElementById('scene');
const scene=new THREE.Scene();
scene.background=new THREE.Color('#e8f4f8');
scene.fog=new THREE.Fog('#e8f4f8',40,120);

const camera=new THREE.PerspectiveCamera(70,wrap.clientWidth/wrap.clientHeight,0.1,200);
camera.position.set(0,2.5,40);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(wrap.clientWidth,wrap.clientHeight);
renderer.shadowMap.enabled=true;
wrap.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.7));
const sun=new THREE.DirectionalLight(0xffffff,1);
sun.position.set(20,30,20);
sun.castShadow=true;
scene.add(sun);

// Floor with texture pattern
const canvas=document.createElement('canvas');
canvas.width=canvas.height=512;
const ctx=canvas.getContext('2d');
ctx.fillStyle='#dcdcdc';
ctx.fillRect(0,0,512,512);
ctx.strokeStyle='#c0c0c0';
ctx.lineWidth=2;
for(let i=0;i<512;i+=64){
  ctx.beginPath();
  ctx.moveTo(i,0);
  ctx.lineTo(i,512);
  ctx.moveTo(0,i);
  ctx.lineTo(512,i);
  ctx.stroke();
}
const texture=new THREE.CanvasTexture(canvas);
texture.wrapS=texture.wrapT=THREE.RepeatWrapping;
texture.repeat.set(20,20);

// Floor sections with different colors
const floorSections = [
  // Entrance (blue)
  {x: 0, z: 40, w: 40, d: 15, color: '#b3d9ff'},
  // Living Room (warm brown)
  {x: -30, z: 0, w: 30, d: 30, color: '#e6ccb3'},
  // Bedroom (soft beige)
  {x: 25, z: 5, w: 25, d: 25, color: '#f5e6d3'},
  // Kitchen (light gray)
  {x: -25, z: 25, w: 20, d: 20, color: '#e8e8e8'},
  // Office (cool gray)
  {x: 20, z: 25, w: 25, d: 20, color: '#d4d4d4'},
  // Marketplace (white)
  {x: 0, z: 45, w: 40, d: 10, color: '#ffffff'},
  // Warehouse (wood brown)
  {x: 45, z: 47, w: 15, d: 13, color: '#c4a57b'},
  // Checkout (blue)
  {x: 0, z: 54, w: 30, d: 6, color: '#b3d9ff'}
];

floorSections.forEach(section => {
  const sectionFloor = new THREE.Mesh(
    new THREE.PlaneGeometry(section.w, section.d),
    new THREE.MeshStandardMaterial({color: section.color, roughness: 0.9})
  );
  sectionFloor.rotation.x = -Math.PI/2;
  sectionFloor.position.set(section.x, 0.05, section.z);
  sectionFloor.receiveShadow = true;
  scene.add(sectionFloor);
  
  // Add border to each section
  const borderGeo = new THREE.EdgesGeometry(new THREE.PlaneGeometry(section.w, section.d));
  const borderMat = new THREE.LineBasicMaterial({color: '#888', linewidth: 2});
  const border = new THREE.LineSegments(borderGeo, borderMat);
  border.rotation.x = -Math.PI/2;
  border.position.set(section.x, 0.06, section.z);
  scene.add(border);
});

// Main walkway roads throughout the store
function createRoad(x, z, width, depth) {
  const roadCanvas = document.createElement('canvas');
  roadCanvas.width = 512;
  roadCanvas.height = 512;
  const roadCtx = roadCanvas.getContext('2d');
  
  // Dark gray road
  roadCtx.fillStyle = '#4a4a4a';
  roadCtx.fillRect(0, 0, 512, 512);
  
  // Yellow center line dashes
  roadCtx.strokeStyle = '#ffd700';
  roadCtx.lineWidth = 8;
  roadCtx.setLineDash([30, 20]);
  roadCtx.beginPath();
  roadCtx.moveTo(256, 0);
  roadCtx.lineTo(256, 512);
  roadCtx.stroke();
  
  // White edge lines
  roadCtx.strokeStyle = '#ffffff';
  roadCtx.lineWidth = 6;
  roadCtx.setLineDash([]);
  roadCtx.beginPath();
  roadCtx.moveTo(50, 0);
  roadCtx.lineTo(50, 512);
  roadCtx.moveTo(462, 0);
  roadCtx.lineTo(462, 512);
  roadCtx.stroke();
  
  const roadTexture = new THREE.CanvasTexture(roadCanvas);
  roadTexture.wrapS = roadTexture.wrapT = THREE.RepeatWrapping;
  roadTexture.repeat.set(1, depth / width);
  
  const road = new THREE.Mesh(
    new THREE.PlaneGeometry(width, depth),
    new THREE.MeshStandardMaterial({map: roadTexture, roughness: 0.8})
  );
  road.rotation.x = -Math.PI/2;
  road.position.set(x, 0.08, z);
  road.receiveShadow = true;
  scene.add(road);
}

// Create main walkway paths
// Pedestrian crossing markings
function createCrossing(x, z, width) {
  const crossingCanvas = document.createElement('canvas');
  crossingCanvas.width = 512;
  crossingCanvas.height = 128;
  const ctx = crossingCanvas.getContext('2d');
  
  ctx.fillStyle = '#4a4a4a';
  ctx.fillRect(0, 0, 512, 128);
  
  // White stripes
  ctx.fillStyle = '#ffffff';
  for (let i = 0; i < 8; i++) {
    ctx.fillRect(i * 64, 0, 50, 128);
  }
  
  const crossingTexture = new THREE.CanvasTexture(crossingCanvas);
  const crossing = new THREE.Mesh(
    new THREE.PlaneGeometry(width, 2),
    new THREE.MeshStandardMaterial({map: crossingTexture, roughness: 0.8})
  );
  crossing.rotation.x = -Math.PI/2;
  crossing.position.set(x, 0.09, z);
  scene.add(crossing);
}

createCrossing(0, 35, 4);
createCrossing(-10, 15, 3);
createCrossing(15, 25, 3);

// Create main walkway paths after defining the function
createRoad(0, 20, 4, 80); // Main central corridor
createRoad(-20, 0, 3, 30); // Living room corridor
createRoad(20, 15, 3, 35); // Bedroom/Office corridor
createRoad(0, 48, 5, 20); // Marketplace corridor
createRoad(35, 45, 3, 15); // Warehouse corridor

let clickables=[];

function wall(w,h,d,x,y,z,col){
  const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),new THREE.MeshStandardMaterial({color:col}));
  m.position.set(x,y,z);
  m.castShadow=m.receiveShadow=true;
  scene.add(m);
  return m;
}

// Outer Walls
wall(120,12,1,0,6,-60,'#e8e8e8');
wall(120,12,1,0,6,60,'#e8e8e8');
wall(1,12,120,-60,6,0,'#e8e8e8');
wall(1,12,120,60,6,0,'#e8e8e8');

// Complete Roof Structure
function createRoof() {
  // Main flat roof sections
  const roofSections = [
    {x: 0, z: 0, w: 120, d: 120}
  ];
  
  roofSections.forEach(section => {
    // Roof surface with texture
    const roofCanvas = document.createElement('canvas');
    roofCanvas.width = 512;
    roofCanvas.height = 512;
    const roofCtx = roofCanvas.getContext('2d');
    
    // Metal roof texture
    roofCtx.fillStyle = '#708090';
    roofCtx.fillRect(0, 0, 512, 512);
    
    // Corrugated lines
    for (let i = 0; i < 512; i += 8) {
      roofCtx.strokeStyle = i % 16 === 0 ? '#556677' : '#889099';
      roofCtx.lineWidth = 2;
      roofCtx.beginPath();
      roofCtx.moveTo(i, 0);
      roofCtx.lineTo(i, 512);
      roofCtx.stroke();
    }
    
    // Weathering spots
    for (let i = 0; i < 30; i++) {
      roofCtx.fillStyle = `rgba(100,100,100,${Math.random() * 0.2})`;
      roofCtx.beginPath();
      roofCtx.arc(Math.random() * 512, Math.random() * 512, Math.random() * 20 + 5, 0, Math.PI * 2);
      roofCtx.fill();
    }
    
    const roofTexture = new THREE.CanvasTexture(roofCanvas);
    roofTexture.wrapS = roofTexture.wrapT = THREE.RepeatWrapping;
    roofTexture.repeat.set(10, 10);
    
    const roof = new THREE.Mesh(
      new THREE.PlaneGeometry(section.w, section.d),
      new THREE.MeshStandardMaterial({
        map: roofTexture,
        roughness: 0.7,
        metalness: 0.3
      })
    );
    roof.rotation.x = -Math.PI/2;
    roof.position.set(section.x, 12, section.z);
    roof.receiveShadow = true;
    roof.castShadow = true;
    scene.add(roof);
    
    // Roof edge trim
    const trimColor = '#4a5568';
    
    // Front trim
    const frontTrim = new THREE.Mesh(
      new THREE.BoxGeometry(section.w, 0.3, 0.5),
      new THREE.MeshStandardMaterial({color: trimColor})
    );
    frontTrim.position.set(section.x, 12.15, section.z + section.d/2);
    frontTrim.castShadow = true;
    scene.add(frontTrim);
    
    // Back trim
    const backTrim = new THREE.Mesh(
      new THREE.BoxGeometry(section.w, 0.3, 0.5),
      new THREE.MeshStandardMaterial({color: trimColor})
    );
    backTrim.position.set(section.x, 12.15, section.z - section.d/2);
    backTrim.castShadow = true;
    scene.add(backTrim);
    
    // Left trim
    const leftTrim = new THREE.Mesh(
      new THREE.BoxGeometry(0.5, 0.3, section.d),
      new THREE.MeshStandardMaterial({color: trimColor})
    );
    leftTrim.position.set(section.x - section.w/2, 12.15, section.z);
    leftTrim.castShadow = true;
    scene.add(leftTrim);
    
    // Right trim
    const rightTrim = new THREE.Mesh(
      new THREE.BoxGeometry(0.5, 0.3, section.d),
      new THREE.MeshStandardMaterial({color: trimColor})
    );
    rightTrim.position.set(section.x + section.w/2, 12.15, section.z);
    rightTrim.castShadow = true;
    scene.add(rightTrim);
  });
  
  // Skylights for natural lighting
  const skylightPositions = [
    {x: -30, z: 0},
    {x: 25, z: 5},
    {x: 0, z: 25},
    {x: 0, z: 48}
  ];
  
  skylightPositions.forEach(pos => {
    const skylight = new THREE.Mesh(
      new THREE.BoxGeometry(6, 0.2, 4),
      new THREE.MeshStandardMaterial({
        color: '#87ceeb',
        transparent: true,
        opacity: 0.4,
        emissive: '#ffffff',
        emissiveIntensity: 0.3
      })
    );
    skylight.position.set(pos.x, 11.9, pos.z);
    scene.add(skylight);
    
    // Skylight frame
    const frame = new THREE.Mesh(
      new THREE.BoxGeometry(6.2, 0.15, 4.2),
      new THREE.MeshStandardMaterial({color: '#2c3e50'})
    );
    frame.position.set(pos.x, 11.85, pos.z);
    scene.add(frame);
    
    // Add light from skylight
    const skylightLight = new THREE.PointLight(0xffffee, 0.5, 15);
    skylightLight.position.set(pos.x, 11, pos.z);
    scene.add(skylightLight);
  });
  
  // Roof ventilation units
  const ventPositions = [
    {x: -40, z: -20},
    {x: 40, z: -20},
    {x: -40, z: 40},
    {x: 40, z: 40}
  ];
  
  ventPositions.forEach(pos => {
    const vent = new THREE.Mesh(
      new THREE.CylinderGeometry(0.8, 0.8, 1, 16),
      new THREE.MeshStandardMaterial({color: '#6b7280'})
    );
    vent.position.set(pos.x, 12.5, pos.z);
    vent.castShadow = true;
    scene.add(vent);
    
    // Vent cap
    const cap = new THREE.Mesh(
      new THREE.CylinderGeometry(1, 0.8, 0.3, 16),
      new THREE.MeshStandardMaterial({color: '#4b5563'})
    );
    cap.position.set(pos.x, 13.1, pos.z);
    cap.castShadow = true;
    scene.add(cap);
  });
  
  // IKEA logo on roof (visible from above)
  const roofLogoCanvas = document.createElement('canvas');
  roofLogoCanvas.width = 1024;
  roofLogoCanvas.height = 512;
  const logoCtx = roofLogoCanvas.getContext('2d');
  logoCtx.fillStyle = '#0058a3';
  logoCtx.fillRect(0, 0, 1024, 512);
  logoCtx.fillStyle = '#ffda1a';
  logoCtx.font = 'bold 300px Arial';
  logoCtx.textAlign = 'center';
  logoCtx.fillText('IKEA', 512, 370);
  
  const roofLogoTexture = new THREE.CanvasTexture(roofLogoCanvas);
  const roofLogo = new THREE.Mesh(
    new THREE.PlaneGeometry(40, 20),
    new THREE.MeshStandardMaterial({map: roofLogoTexture})
  );
  roofLogo.rotation.x = -Math.PI/2;
  roofLogo.position.set(0, 12.05, 0);
  scene.add(roofLogo);
}

createRoof();

// Interior Section Dividers
// Living Room section wall
wall(30,8,0.5,-30,4,10,'#d4a373');
wall(20,8,0.5,-15,4,-10,'#d4a373');

// Bedroom section wall
wall(25,8,0.5,25,4,15,'#d4a373');
wall(15,8,0.5,35,4,5,'#d4a373');

// Kitchen section wall
wall(20,8,0.5,-25,4,35,'#d4a373');

// Office section wall
wall(25,8,0.5,30,4,35,'#d4a373');

// Marketplace entrance walls
wall(0.5,6,15,-20,3,47,'#fff');
wall(0.5,6,15,20,3,47,'#fff');

// Warehouse section walls
wall(25,8,0.5,35,4,35,'#8b7355');
wall(0.5,8,20,48,4,48,'#8b7355');

// Section name blocks above walls
function sectionLabel(text, x, y, z, bgColor) {
  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 256;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, 1024, 256);
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 90px Arial';
  ctx.textAlign = 'center';
  ctx.fillText(text, 512, 150);
  const texture = new THREE.CanvasTexture(canvas);
  const mesh = new THREE.Mesh(
    new THREE.PlaneGeometry(10, 2.5),
    new THREE.MeshStandardMaterial({map: texture})
  );
  mesh.position.set(x, y, z);
  scene.add(mesh);
  return mesh;
}

sectionLabel('LIVING ROOM', -30, 9, 10, '#d4a373');
sectionLabel('BEDROOM', 25, 9, 15, '#d4a373');
sectionLabel('KITCHEN', -25, 9, 35, '#d4a373');
sectionLabel('OFFICE', 30, 9, 35, '#d4a373');
sectionLabel('MARKETPLACE', 0, 7, 47, '#0058a3');
sectionLabel('WAREHOUSE', 35, 9, 35, '#8b7355');

// Garden Shed/Storage Shed display area
const shedAreaX = -45;
const shedAreaZ = 30;

// Create outdoor shed section label
sectionLabel('OUTDOOR SHEDS', shedAreaX, 9, shedAreaZ - 10, '#6b8e23');

// Shed floor section
const shedFloor = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 25),
  new THREE.MeshStandardMaterial({color: '#9dc183', roughness: 0.9})
);
shedFloor.rotation.x = -Math.PI/2;
shedFloor.position.set(shedAreaX, 0.05, shedAreaZ);
shedFloor.receiveShadow = true;
scene.add(shedFloor);

// Create a detailed garden shed
function createShed(x, y, z, width, height, depth, roofColor, wallColor, name, desc) {
  // Shed base/floor
  const base = new THREE.Mesh(
    new THREE.BoxGeometry(width, 0.2, depth),
    new THREE.MeshStandardMaterial({color: '#8b7355'})
  );
  base.position.set(x, y, z);
  base.castShadow = base.receiveShadow = true;
  scene.add(base);
  
  // Shed walls
  const wallHeight = height * 0.6;
  
  // Front wall with door
  const frontLeft = new THREE.Mesh(
    new THREE.BoxGeometry(width * 0.3, wallHeight, 0.2),
    new THREE.MeshStandardMaterial({color: wallColor})
  );
  frontLeft.position.set(x - width * 0.35, y + wallHeight/2, z + depth/2);
  frontLeft.castShadow = true;
  scene.add(frontLeft);
  
  const frontRight = new THREE.Mesh(
    new THREE.BoxGeometry(width * 0.3, wallHeight, 0.2),
    new THREE.MeshStandardMaterial({color: wallColor})
  );
  frontRight.position.set(x + width * 0.35, y + wallHeight/2, z + depth/2);
  frontRight.castShadow = true;
  scene.add(frontRight);
  
  const frontTop = new THREE.Mesh(
    new THREE.BoxGeometry(width * 0.4, wallHeight * 0.3, 0.2),
    new THREE.MeshStandardMaterial({color: wallColor})
  );
  frontTop.position.set(x, y + wallHeight * 0.85, z + depth/2);
  frontTop.castShadow = true;
  scene.add(frontTop);
  
  // Door
  const door = new THREE.Mesh(
    new THREE.BoxGeometry(width * 0.35, wallHeight * 0.7, 0.15),
    new THREE.MeshStandardMaterial({color: '#654321'})
  );
  door.position.set(x, y + wallHeight * 0.35, z + depth/2 + 0.1);
  door.castShadow = true;
  scene.add(door);
  
  // Door handle
  const handle = new THREE.Mesh(
    new THREE.SphereGeometry(0.1, 8, 8),
    new THREE.MeshStandardMaterial({color: '#c0c0c0'})
  );
  handle.position.set(x + width * 0.12, y + wallHeight * 0.35, z + depth/2 + 0.2);
  scene.add(handle);
  
  // Back wall
  const back = new THREE.Mesh(
    new THREE.BoxGeometry(width, wallHeight, 0.2),
    new THREE.MeshStandardMaterial({color: wallColor})
  );
  back.position.set(x, y + wallHeight/2, z - depth/2);
  back.castShadow = true;
  scene.add(back);
  
  // Side walls with window
  const leftWall = new THREE.Mesh(
    new THREE.BoxGeometry(0.2, wallHeight, depth),
    new THREE.MeshStandardMaterial({color: wallColor})
  );
  leftWall.position.set(x - width/2, y + wallHeight/2, z);
  leftWall.castShadow = true;
  scene.add(leftWall);
  
  const rightWall = new THREE.Mesh(
    new THREE.BoxGeometry(0.2, wallHeight, depth),
    new THREE.MeshStandardMaterial({color: wallColor})
  );
  rightWall.position.set(x + width/2, y + wallHeight/2, z);
  rightWall.castShadow = true;
  scene.add(rightWall);
  
  // Window on side
  const window = new THREE.Mesh(
    new THREE.BoxGeometry(0.25, wallHeight * 0.3, depth * 0.3),
    new THREE.MeshStandardMaterial({color: '#87ceeb', transparent: true, opacity: 0.6})
  );
  window.position.set(x + width/2, y + wallHeight * 0.6, z);
  scene.add(window);
  
  // Pitched roof
  const roofGeo = new THREE.BufferGeometry();
  const roofVertices = new Float32Array([
    // Front triangle
    -width/2, wallHeight, depth/2,
    width/2, wallHeight, depth/2,
    0, height, depth/2,
    // Back triangle
    -width/2, wallHeight, -depth/2,
    width/2, wallHeight, -depth/2,
    0, height, -depth/2,
    // Left slope
    -width/2, wallHeight, depth/2,
    0, height, depth/2,
    0, height, -depth/2,
    -width/2, wallHeight, depth/2,
    0, height, -depth/2,
    -width/2, wallHeight, -depth/2,
    // Right slope
    width/2, wallHeight, depth/2,
    0, height, depth/2,
    0, height, -depth/2,
    width/2, wallHeight, depth/2,
    0, height, -depth/2,
    width/2, wallHeight, -depth/2
  ]);
  roofGeo.setAttribute('position', new THREE.BufferAttribute(roofVertices, 3));
  roofGeo.computeVertexNormals();
  
  const roof = new THREE.Mesh(
    roofGeo,
    new THREE.MeshStandardMaterial({color: roofColor, side: THREE.DoubleSide})
  );
  roof.position.set(x, y, z);
  roof.castShadow = true;
  scene.add(roof);
  
  // Clickable info box
  const infoBox = new THREE.Mesh(
    new THREE.BoxGeometry(width, height, depth),
    new THREE.MeshBasicMaterial({visible: false})
  );
  infoBox.position.set(x, y + height/2, z);
  infoBox.userData = {name: name, desc: desc};
  scene.add(infoBox);
  clickables.push(infoBox);
}

// Create multiple shed displays
createShed(shedAreaX - 6, 0.1, shedAreaZ - 5, 4, 4, 3, '#8b4513', '#d2b48c', 
  'Classic Garden Shed', 'Wooden storage shed 8x6ft. Weather-resistant. Perfect for tools and equipment. $899');

createShed(shedAreaX + 6, 0.1, shedAreaZ - 5, 3.5, 3.5, 2.5, '#2f4f4f', '#708090', 
  'Metal Storage Shed', 'Galvanized steel shed 7x5ft. Rust-proof, lockable door. Low maintenance. $649');

createShed(shedAreaX - 6, 0.1, shedAreaZ + 8, 5, 4.5, 4, '#654321', '#f5deb3', 
  'Premium Workshop Shed', 'Large 10x8ft shed with windows. Perfect for workshop or hobby space. $1,299');

createShed(shedAreaX + 6, 0.1, shedAreaZ + 8, 3, 3, 2, '#556b2f', '#8fbc8f', 
  'Compact Tool Shed', 'Small 6x4ft shed. Ideal for garden tools. Easy assembly. $449');

// Add garden accessories near sheds
product(shedAreaX - 8, 0.3, shedAreaZ + 2, 1, 0.6, 0.8, '#228b22', 'Wheelbarrow', 'Heavy-duty steel. $89', 'table');
product(shedAreaX + 8, 0.3, shedAreaZ + 2, 0.8, 1.2, 0.5, '#8b4513', 'Garden Tools Set', 'Spade, rake, hoe. $129', 'table');
product(shedAreaX, 0.5, shedAreaZ + 15, 2, 1, 1.5, '#6b8e23', 'Potting Bench', 'Workspace for plants. $199', 'desk');

// Add info hotspot for shed area
hotspot(shedAreaX, 2, shedAreaZ, 'Outdoor Sheds', 'Complete range of garden sheds and storage solutions. Free assembly service available. Delivery within 5-7 days.');
const brand1=new THREE.Mesh(new THREE.PlaneGeometry(40,3),new THREE.MeshStandardMaterial({color:'#0058a3'}));
brand1.position.set(0,8,-59.9);
scene.add(brand1);

const brand2=new THREE.Mesh(new THREE.PlaneGeometry(40,1.2),new THREE.MeshStandardMaterial({color:'#ffda1a'}));
brand2.position.set(0,6,-59.9);
scene.add(brand2);

// IKEA Logo Text
const logoCanvas=document.createElement('canvas');
logoCanvas.width=1024;
logoCanvas.height=256;
const logoCtx=logoCanvas.getContext('2d');
logoCtx.fillStyle='#0058a3';
logoCtx.fillRect(0,0,1024,256);
logoCtx.fillStyle='#ffda1a';
logoCtx.font='bold 180px Arial';
logoCtx.textAlign='center';
logoCtx.fillText('IKEA',512,190);
const logoTexture=new THREE.CanvasTexture(logoCanvas);
const logoMesh=new THREE.Mesh(
  new THREE.PlaneGeometry(20,5),
  new THREE.MeshStandardMaterial({map:logoTexture})
);
logoMesh.position.set(0,9,-59.8);
scene.add(logoMesh);

// Welcome Sign
const welcomeCanvas=document.createElement('canvas');
welcomeCanvas.width=1024;
welcomeCanvas.height=512;
const welCtx=welcomeCanvas.getContext('2d');
welCtx.fillStyle='#ffffff';
welCtx.fillRect(0,0,1024,512);

// Border
welCtx.strokeStyle='#0058a3';
welCtx.lineWidth=10;
welCtx.strokeRect(10,10,1004,492);

// Welcome text
welCtx.fillStyle='#0058a3';
welCtx.font='bold 120px Arial';
welCtx.textAlign='center';
welCtx.fillText('WELCOME',512,160);

// Subtitle
welCtx.font='60px Arial';
welCtx.fillText('to IKEA Store',512,240);

// Store hours
welCtx.fillStyle='#333';
welCtx.font='bold 50px Arial';
welCtx.fillText('STORE HOURS',512,330);
welCtx.font='45px Arial';
welCtx.fillText('Monday - Saturday: 10:00 AM - 9:00 PM',512,390);
welCtx.fillText('Sunday: 11:00 AM - 7:00 PM',512,450);

const welcomeTexture=new THREE.CanvasTexture(welcomeCanvas);
const welcomeMesh=new THREE.Mesh(
  new THREE.PlaneGeometry(16,8),
  new THREE.MeshStandardMaterial({map:welcomeTexture})
);
welcomeMesh.position.set(0,5,33);
scene.add(welcomeMesh);

// Add texture to walls (wood panel effect for showroom)
function addTexture(mesh,color){
  const c=document.createElement('canvas');
  c.width=c.height=256;
  const ct=c.getContext('2d');
  ct.fillStyle=color;
  ct.fillRect(0,0,256,256);
  for(let i=0;i<30;i++){
    ct.strokeStyle=`rgba(0,0,0,${Math.random()*0.1})`;
    ct.lineWidth=Math.random()*2;
    ct.beginPath();
    ct.moveTo(0,Math.random()*256);
    ct.lineTo(256,Math.random()*256);
    ct.stroke();
  }
  const tex=new THREE.CanvasTexture(c);
  mesh.material.map=tex;
  mesh.material.needsUpdate=true;
}

function createImageTexture(type){
  const canvas=document.createElement('canvas');
  canvas.width=512;
  canvas.height=512;
  const ctx=canvas.getContext('2d');
  
  if(type==='sofa'){
    // Brown sofa with cushions
    ctx.fillStyle='#8b6f47';
    ctx.fillRect(0,0,512,512);
    ctx.fillStyle='#6d5637';
    ctx.fillRect(50,150,412,300);
    // Cushions with detail
    ctx.fillStyle='#9d8157';
    for(let i=0;i<3;i++){
      ctx.fillRect(70+i*140,180,120,120);
      // Cushion borders
      ctx.strokeStyle='#7d6647';
      ctx.lineWidth=3;
      ctx.strokeRect(70+i*140,180,120,120);
    }
    // Armrests with shading
    ctx.fillStyle='#7d6647';
    ctx.fillRect(30,200,80,200);
    ctx.fillRect(402,200,80,200);
    // Shadow details
    ctx.fillStyle='rgba(0,0,0,0.3)';
    ctx.fillRect(50,420,412,30);
    // Fabric texture
    for(let i=0;i<30;i++){
      ctx.strokeStyle=`rgba(0,0,0,${Math.random()*0.1})`;
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(Math.random()*512,150);
      ctx.lineTo(Math.random()*512,450);
      ctx.stroke();
    }
  }else if(type==='bed'){
    // Bed with headboard
    ctx.fillStyle='#c19a6b';
    ctx.fillRect(0,0,512,512);
    // Decorative headboard
    ctx.fillStyle='#b8936b';
    ctx.fillRect(0,0,512,150);
    ctx.strokeStyle='#8d7a5b';
    ctx.lineWidth=4;
    for(let i=0;i<5;i++){
      ctx.strokeRect(20+i*96,10,86,130);
    }
    // Mattress
    ctx.fillStyle='#e8e8e8';
    ctx.fillRect(50,150,412,300);
    // Mattress stitching
    ctx.strokeStyle='#d0d0d0';
    ctx.lineWidth=2;
    for(let i=0;i<8;i++){
      ctx.beginPath();
      ctx.moveTo(50,170+i*35);
      ctx.lineTo(462,170+i*35);
      ctx.stroke();
    }
    // Pillows
    ctx.fillStyle='#f5f5f5';
    ctx.fillRect(100,160,150,80);
    ctx.fillRect(262,160,150,80);
    ctx.strokeStyle='#e0e0e0';
    ctx.strokeRect(100,160,150,80);
    ctx.strokeRect(262,160,150,80);
    // Blanket fold
    ctx.fillStyle='#d4a574';
    ctx.fillRect(50,380,412,70);
    ctx.strokeStyle='#c4956b';
    ctx.lineWidth=3;
    for(let i=0;i<10;i++){
      ctx.beginPath();
      ctx.moveTo(50+i*42,380);
      ctx.lineTo(50+i*42,450);
      ctx.stroke();
    }
  }else if(type==='table'){
    // Coffee table top view
    ctx.fillStyle='#654321';
    ctx.fillRect(0,0,512,512);
    // Wood grain details
    ctx.strokeStyle='rgba(50,30,10,0.4)';
    for(let i=0;i<40;i++){
      ctx.lineWidth=Math.random()*3+1;
      ctx.beginPath();
      ctx.moveTo(0,Math.random()*512);
      ctx.lineTo(512,Math.random()*512);
      ctx.stroke();
    }
    // Wood knots
    for(let i=0;i<5;i++){
      ctx.fillStyle='rgba(40,25,10,0.6)';
      ctx.beginPath();
      ctx.arc(Math.random()*512,Math.random()*512,Math.random()*20+10,0,Math.PI*2);
      ctx.fill();
    }
    // Table edge with detail
    ctx.fillStyle='#4d3621';
    ctx.fillRect(0,0,512,40);
    ctx.fillRect(0,472,512,40);
    ctx.fillRect(0,0,40,512);
    ctx.fillRect(472,0,40,512);
    // Edge highlight
    ctx.strokeStyle='#6d5631';
    ctx.lineWidth=3;
    ctx.strokeRect(40,40,432,432);
  }else if(type==='desk'){
    // Office desk with more detail
    ctx.fillStyle='#34495e';
    ctx.fillRect(0,0,512,512);
    // Desktop surface
    ctx.fillStyle='#3d566e';
    ctx.fillRect(20,20,472,100);
    // Drawer with detail
    ctx.fillStyle='#2c3e50';
    ctx.fillRect(50,300,150,180);
    ctx.strokeStyle='#bdc3c7';
    ctx.lineWidth=3;
    ctx.strokeRect(50,300,150,180);
    // Drawer lines
    ctx.strokeRect(50,360,150,60);
    ctx.strokeRect(50,420,150,60);
    // Handles
    ctx.fillStyle='#95a5a6';
    ctx.fillRect(110,335,30,8);
    ctx.fillRect(110,395,30,8);
    ctx.fillRect(110,455,30,8);
    // Desk legs
    ctx.fillStyle='#2c3e50';
    ctx.fillRect(30,120,20,392);
    ctx.fillRect(180,120,20,392);
    ctx.fillRect(300,120,20,392);
    ctx.fillRect(470,120,20,392);
  }else if(type==='chair'){
    // Office chair with mesh detail
    ctx.fillStyle='#2c3e50';
    ctx.fillRect(0,0,512,512);
    // Seat cushion
    ctx.fillStyle='#34495e';
    ctx.fillRect(100,250,312,200);
    ctx.strokeStyle='#2c3e50';
    ctx.lineWidth=3;
    ctx.strokeRect(100,250,312,200);
    // Cushion padding detail
    for(let i=0;i<3;i++){
      for(let j=0;j<3;j++){
        ctx.strokeStyle='rgba(0,0,0,0.2)';
        ctx.lineWidth=2;
        ctx.strokeRect(120+i*90,270+j*60,70,40);
      }
    }
    // Backrest
    ctx.fillStyle='#2c3e50';
    ctx.fillRect(150,50,212,250);
    // Mesh pattern
    ctx.strokeStyle='rgba(255,255,255,0.15)';
    ctx.lineWidth=2;
    for(let i=0;i<25;i++){
      ctx.beginPath();
      ctx.moveTo(150,50+i*10);
      ctx.lineTo(362,50+i*10);
      ctx.stroke();
    }
    for(let i=0;i<21;i++){
      ctx.beginPath();
      ctx.moveTo(150+i*10,50);
      ctx.lineTo(150+i*10,300);
      ctx.stroke();
    }
    // Armrests
    ctx.fillStyle='#34495e';
    ctx.fillRect(80,280,15,100);
    ctx.fillRect(417,280,15,100);
    // Base star with wheels
    ctx.fillStyle='#2c3e50';
    for(let i=0;i<5;i++){
      ctx.save();
      ctx.translate(256,480);
      ctx.rotate((i*Math.PI*2)/5);
      ctx.fillRect(-8,-60,16,60);
      ctx.restore();
    }
  }else if(type==='wardrobe'){
    // Wardrobe with detailed doors
    ctx.fillStyle='#f5f5dc';
    ctx.fillRect(0,0,512,512);
    // Door panels with detail
    for(let i=0;i<3;i++){
      const x=10+i*167;
      ctx.strokeStyle='#d3d3c3';
      ctx.lineWidth=4;
      ctx.strokeRect(x,10,160,492);
      // Inner door panel
      ctx.strokeRect(x+15,25,130,220);
      ctx.strokeRect(x+15,260,130,220);
    }
    // Door handles
    ctx.fillStyle='#888';
    for(let i=0;i<3;i++){
      const x=85+i*167;
      ctx.fillRect(x,250,10,25);
      ctx.fillRect(x-3,245,16,6);
      ctx.fillRect(x-3,269,16,6);
    }
    // Wood grain
    ctx.strokeStyle='rgba(180,180,150,0.3)';
    for(let i=0;i<50;i++){
      ctx.lineWidth=Math.random()*2;
      ctx.beginPath();
      ctx.moveTo(0,Math.random()*512);
      ctx.lineTo(512,Math.random()*512);
      ctx.stroke();
    }
  }else if(type==='kitchen'){
    // Kitchen cabinets with detail
    ctx.fillStyle='#ffffff';
    ctx.fillRect(0,0,512,512);
    // Upper cabinets
    ctx.strokeStyle='#e0e0e0';
    ctx.lineWidth=3;
    for(let i=0;i<4;i++){
      ctx.strokeRect(i*128+5,50,118,200);
      // Cabinet panel
      ctx.strokeRect(i*128+15,65,98,170);
    }
    // Lower cabinets
    for(let i=0;i<4;i++){
      ctx.strokeRect(i*128+5,270,118,200);
      // Two drawers
      ctx.strokeRect(i*128+15,285,98,80);
      ctx.strokeRect(i*128+15,375,98,80);
    }
    // Handles
    ctx.fillStyle='#c0c0c0';
    for(let i=0;i<4;i++){
      ctx.fillRect(i*128+100,140,5,20);
      ctx.fillRect(i*128+100,320,5,15);
      ctx.fillRect(i*128+100,410,5,15);
    }
    // Countertop
    ctx.fillStyle='#8b8b8b';
    ctx.fillRect(0,255,512,15);
  }else if(type==='fridge'){
    // Refrigerator with detail
    ctx.fillStyle='#e5e5e5';
    ctx.fillRect(0,0,512,512);
    // Main door
    ctx.strokeStyle='#c0c0c0';
    ctx.lineWidth=4;
    ctx.strokeRect(20,20,472,320);
    // Freezer door
    ctx.strokeRect(20,360,472,132);
    // Door seals
    ctx.strokeStyle='#a0a0a0';
    ctx.lineWidth=6;
    ctx.strokeRect(25,25,462,310);
    ctx.strokeRect(25,365,462,122);
    // Handle
    ctx.fillStyle='#888';
    ctx.fillRect(450,150,15,60);
    ctx.fillRect(445,145,25,8);
    ctx.fillRect(445,202,25,8);
    // Brand logo area
    ctx.fillStyle='#d0d0d0';
    ctx.fillRect(50,50,100,30);
    ctx.fillStyle='#888';
    ctx.font='bold 20px Arial';
    ctx.fillText('IKEA',55,72);
    // Water dispenser
    ctx.fillStyle='#b0b0b0';
    ctx.fillRect(250,180,80,100);
    ctx.fillRect(265,200,50,20);
  }else if(type==='box'){
    // Cardboard box with IKEA branding
    ctx.fillStyle='#8b7355';
    ctx.fillRect(0,0,512,512);
    // Box flaps
    ctx.strokeStyle='#6d5d4f';
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(256,0);
    ctx.lineTo(456,100);
    ctx.lineTo(456,412);
    ctx.lineTo(256,512);
    ctx.lineTo(56,412);
    ctx.lineTo(56,100);
    ctx.closePath();
    ctx.stroke();
    // Cardboard texture
    for(let i=0;i<100;i++){
      ctx.fillStyle=`rgba(120,100,80,${Math.random()*0.1})`;
      ctx.fillRect(Math.random()*512,Math.random()*512,Math.random()*15,Math.random()*15);
    }
    // IKEA Logo
    ctx.fillStyle='#0058a3';
    ctx.fillRect(140,200,232,120);
    ctx.fillStyle='#ffda1a';
    ctx.font='bold 70px Arial';
    ctx.fillText('IKEA',165,275);
    // Barcode
    ctx.fillStyle='#000';
    for(let i=0;i<20;i++){
      ctx.fillRect(150+i*10,350,Math.random()>0.5?4:2,40);
    }
    // Product code
    ctx.fillStyle='#000';
    ctx.font='16px Arial';
    ctx.fillText('ART.NO: 123.456.78',170,410);
  }else if(type==='nightstand'){
    // Nightstand with detail
    ctx.fillStyle='#8b7355';
    ctx.fillRect(0,0,512,512);
    // Top surface
    ctx.fillStyle='#9d8467';
    ctx.fillRect(30,50,452,30);
    // Drawers
    ctx.fillStyle='#7d6647';
    ctx.fillRect(50,100,412,150);
    ctx.fillRect(50,270,412,150);
    ctx.strokeStyle='#6d5d4f';
    ctx.lineWidth=3;
    ctx.strokeRect(50,100,412,150);
    ctx.strokeRect(50,270,412,150);
    // Drawer panels
    ctx.strokeRect(65,115,382,120);
    ctx.strokeRect(65,285,382,120);
    // Handles
    ctx.fillStyle='#444';
    ctx.fillRect(240,165,32,10);
    ctx.fillRect(240,335,32,10);
    // Handle screws
    ctx.fillStyle='#333';
    ctx.beginPath();
    ctx.arc(243,170,3,0,Math.PI*2);
    ctx.arc(269,170,3,0,Math.PI*2);
    ctx.arc(243,340,3,0,Math.PI*2);
    ctx.arc(269,340,3,0,Math.PI*2);
    ctx.fill();
    // Wood grain
    ctx.strokeStyle='rgba(100,80,60,0.3)';
    for(let i=0;i<60;i++){
      ctx.lineWidth=Math.random()*2;
      ctx.beginPath();
      ctx.moveTo(0,Math.random()*512);
      ctx.lineTo(512,Math.random()*512);
      ctx.stroke();
    }
    // Legs
    ctx.fillStyle='#6d5d4f';
    ctx.fillRect(60,440,15,72);
    ctx.fillRect(437,440,15,72);
  }
  
  return new THREE.CanvasTexture(canvas);
}

function product(x,y,z,w,h,d,col,name,desc,imgType){
  const texture=imgType?createImageTexture(imgType):null;
  const mat=texture?new THREE.MeshStandardMaterial({map:texture,roughness:0.6}):new THREE.MeshStandardMaterial({color:col,roughness:0.7});
  const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),mat);
  m.position.set(x,y,z);
  m.castShadow=m.receiveShadow=true;
  m.userData={name,desc};
  scene.add(m);
  clickables.push(m);
  return m;
}

// Entrance
const entSign=wall(8,2,0.3,0,3,35,'#0058a3');
entSign.userData={name:'Store Entrance',desc:'Main entry with info desk. 15,000+ weekly visitors. Store maps and member services available.'};
clickables.push(entSign);

// Entry/Exit Signs
const entryCanvas=document.createElement('canvas');
entryCanvas.width=512;
entryCanvas.height=512;
const entryCtx=entryCanvas.getContext('2d');
entryCtx.fillStyle='#0058a3';
entryCtx.fillRect(0,0,512,512);

// White border
entryCtx.strokeStyle='#ffffff';
entryCtx.lineWidth=15;
entryCtx.strokeRect(15,15,482,482);

entryCtx.fillStyle='#ffffff';
entryCtx.font='bold 100px Arial';
entryCtx.textAlign='center';
entryCtx.fillText('ENTRANCE',256,200);

// Large arrow
entryCtx.font='120px Arial';
entryCtx.fillText('‚Üì',256,350);

// Additional text
entryCtx.font='40px Arial';
entryCtx.fillText('Welcome!',256,430);

const entryTexture=new THREE.CanvasTexture(entryCanvas);
const entrySign=new THREE.Mesh(
  new THREE.PlaneGeometry(8,8),
  new THREE.MeshStandardMaterial({map:entryTexture})
);
entrySign.position.set(-15,5,32);
scene.add(entrySign);

// Duplicate on right side
const entrySign2=new THREE.Mesh(
  new THREE.PlaneGeometry(8,8),
  new THREE.MeshStandardMaterial({map:entryTexture})
);
entrySign2.position.set(15,5,32);
scene.add(entrySign2);

const exitCanvas=document.createElement('canvas');
exitCanvas.width=512;
exitCanvas.height=512;
const exitCtx=exitCanvas.getContext('2d');
exitCtx.fillStyle='#d32f2f';
exitCtx.fillRect(0,0,512,512);

// White border
exitCtx.strokeStyle='#ffffff';
exitCtx.lineWidth=15;
exitCtx.strokeRect(15,15,482,482);

exitCtx.fillStyle='#ffffff';
exitCtx.font='bold 120px Arial';
exitCtx.textAlign='center';
exitCtx.fillText('EXIT',256,200);

// Large arrow
exitCtx.font='120px Arial';
exitCtx.fillText('‚Üë',256,350);

// Additional text
exitCtx.font='40px Arial';
exitCtx.fillText('Thank You!',256,430);

const exitTexture=new THREE.CanvasTexture(exitCanvas);
const exitSign=new THREE.Mesh(
  new THREE.PlaneGeometry(8,8),
  new THREE.MeshStandardMaterial({map:exitTexture})
);
exitSign.position.set(-12,5,58);
exitSign.rotation.y=Math.PI;
scene.add(exitSign);

const exitSign2=new THREE.Mesh(
  new THREE.PlaneGeometry(8,8),
  new THREE.MeshStandardMaterial({map:exitTexture})
);
exitSign2.position.set(12,5,58);
exitSign2.rotation.y=Math.PI;
scene.add(exitSign2);

product(-8,0.5,38,3,1,2,'#8b4513','Reception Desk','Customer service & information','desk');

// Living Room Showroom
for(let i=0;i<3;i++){
  const x=-25+i*10;
  product(x,0.5,0,4,1,2.5,'#8b6f47','Sofa Set '+(i+1),'3-seat sofa $699-$1299','sofa');
  product(x-2,0.3,3,1.5,0.6,1.5,'#654321','Coffee Table','Wood $149','table');
  product(x+3,1.2,0,0.8,2.5,0.5,'#2c3e50','TV Stand','$199','table');
}

const livSign=wall(6,1.5,0.2,-20,4,-10,'#3498db');
livSign.userData={name:'Living Room',desc:'Complete living room displays. Test furniture comfort. Staff consultations available.'};
clickables.push(livSign);

// Bedroom
for(let i=0;i<2;i++){
  const x=15+i*12;
  product(x,1,5,4,2,5,'#c19a6b','Bed Frame '+(i+1),'Queen with storage $399','bed');
  product(x+4,0.8,5,1.5,1.8,1.2,'#8b7355','Nightstand','2-drawer $79','nightstand');
  product(x-4,2,5,2,4,1.5,'#f5f5dc','Wardrobe','3-door $599','wardrobe');
}

const bedSign=wall(6,1.5,0.2,20,4,-5,'#3498db');
bedSign.userData={name:'Bedroom',desc:'Complete bedroom solutions. Mattress testing area. Sleep specialists available.'};
clickables.push(bedSign);

// Kitchen
product(-20,0.5,25,8,1,3,'#ffffff','Kitchen Unit','Complete kitchen $1,299','kitchen');
product(-20,1.5,22,2,3,2,'#e5e5e5','Refrigerator','$499','fridge');

const kitSign=wall(6,1.5,0.2,-20,4,15,'#3498db');
kitSign.userData={name:'Kitchen',desc:'Modular systems. Free 3D design service. Planning appointments available.'};
clickables.push(kitSign);

// Office
for(let i=0;i<3;i++){
  const x=12+i*8;
  product(x,0.8,25,3.5,1.6,2,'#34495e','Desk '+(i+1),'Height adjustable $299','desk');
  product(x,1.8,27,1.2,2.2,1.2,'#2c3e50','Office Chair','Ergonomic $249','chair');
}

const offSign=wall(6,1.5,0.2,20,4,15,'#3498db');
offSign.userData={name:'Office',desc:'Home office solutions. Ergonomic furniture. Business bulk orders available.'};
clickables.push(offSign);

// Marketplace
for(let x=-15;x<20;x+=8){
  for(let z=42;z<50;z+=4){
    product(x,0.5,z,3,1,2,'#f0f0f0','Display','Accessories & textiles','table');
  }
}

const markSign=wall(8,1.5,0.2,0,4,40,'#3498db');
markSign.userData={name:'Marketplace',desc:'Self-service small items. Kitchen accessories, textiles, decor. High-margin products.'};
clickables.push(markSign);

// Warehouse
for(let x=35;x<55;x+=5){
  for(let z=43;z<52;z+=4){
    product(x,2,z,3,4,3,'#8b7355','Stock','Flat-pack furniture','box');
  }
}

const wareSign=wall(8,1.5,0.2,45,4,38,'#3498db');
wareSign.userData={name:'Warehouse',desc:'Self-service pickup. Products by aisle/bin. Real-time stock via app. Trolleys available.'};
clickables.push(wareSign);

// Checkout
for(let i=0;i<5;i++){
  product(-12+i*6,0.6,54,2.5,1.2,1,'#0058a3','Checkout '+(i+1),'Card/cash/mobile pay','desk');
}

const checkSign=wall(8,1.5,0.2,0,4,50,'#3498db');
checkSign.userData={name:'Checkout',desc:'Multiple lanes. Self-checkout available. Avg transaction: 3-4 min. Family card benefits.'};
clickables.push(checkSign);

// Hotspots (realistic human figures)
function hotspot(x,y,z,name,info){
  // Create a realistic human figure
  const humanGroup = new THREE.Group();
  
  // Head with more detail
  const head = new THREE.Mesh(
    new THREE.SphereGeometry(0.25, 32, 32),
    new THREE.MeshStandardMaterial({
      color: '#ffdbac',
      roughness: 0.8,
      metalness: 0.1
    })
  );
  head.position.set(0, 1.65, 0);
  head.scale.set(1, 1.1, 0.9);
  head.castShadow = true;
  humanGroup.add(head);
  
  // Hair
  const hair = new THREE.Mesh(
    new THREE.SphereGeometry(0.26, 32, 32),
    new THREE.MeshStandardMaterial({color: '#3d2817', roughness: 0.9})
  );
  hair.position.set(0, 1.75, -0.05);
  hair.scale.set(1, 0.8, 1);
  hair.castShadow = true;
  humanGroup.add(hair);
  
  // Eyes
  const leftEye = new THREE.Mesh(
    new THREE.SphereGeometry(0.04, 16, 16),
    new THREE.MeshStandardMaterial({color: '#2c1810'})
  );
  leftEye.position.set(-0.08, 1.7, 0.22);
  humanGroup.add(leftEye);
  
  const rightEye = new THREE.Mesh(
    new THREE.SphereGeometry(0.04, 16, 16),
    new THREE.MeshStandardMaterial({color: '#2c1810'})
  );
  rightEye.position.set(0.08, 1.7, 0.22);
  humanGroup.add(rightEye);
  
  // Nose
  const nose = new THREE.Mesh(
    new THREE.SphereGeometry(0.03, 16, 16),
    new THREE.MeshStandardMaterial({color: '#ffc9a0'})
  );
  nose.position.set(0, 1.62, 0.25);
  nose.scale.set(0.8, 1, 1.2);
  humanGroup.add(nose);
  
  // Neck
  const neck = new THREE.Mesh(
    new THREE.CylinderGeometry(0.12, 0.13, 0.15, 16),
    new THREE.MeshStandardMaterial({color: '#ffdbac', roughness: 0.8})
  );
  neck.position.set(0, 1.48, 0);
  neck.castShadow = true;
  humanGroup.add(neck);
  
  // Torso (more realistic shape)
  const torsoShape = new THREE.Shape();
  torsoShape.moveTo(-0.3, 0);
  torsoShape.lineTo(-0.35, -0.3);
  torsoShape.lineTo(-0.3, -0.6);
  torsoShape.lineTo(0.3, -0.6);
  torsoShape.lineTo(0.35, -0.3);
  torsoShape.lineTo(0.3, 0);
  torsoShape.lineTo(-0.3, 0);
  
  const extrudeSettings = {
    steps: 1,
    depth: 0.25,
    bevelEnabled: true,
    bevelThickness: 0.05,
    bevelSize: 0.05,
    bevelSegments: 8
  };
  
  const torsoGeometry = new THREE.ExtrudeGeometry(torsoShape, extrudeSettings);
  const torso = new THREE.Mesh(
    torsoGeometry,
    new THREE.MeshStandardMaterial({color: '#0058a3', roughness: 0.7})
  );
  torso.position.set(0, 1.4, -0.125);
  torso.castShadow = true;
  humanGroup.add(torso);
  
  // Shirt collar
  const collar = new THREE.Mesh(
    new THREE.TorusGeometry(0.15, 0.03, 16, 32, Math.PI),
    new THREE.MeshStandardMaterial({color: '#004080'})
  );
  collar.position.set(0, 1.4, 0.05);
  collar.rotation.x = Math.PI / 2;
  humanGroup.add(collar);
  
  // Left shoulder and arm (more anatomical)
  const leftShoulder = new THREE.Mesh(
    new THREE.SphereGeometry(0.15, 16, 16),
    new THREE.MeshStandardMaterial({color: '#0058a3', roughness: 0.7})
  );
  leftShoulder.position.set(-0.4, 1.3, 0);
  leftShoulder.castShadow = true;
  humanGroup.add(leftShoulder);
  
  const leftUpperArm = new THREE.Mesh(
    new THREE.CylinderGeometry(0.09, 0.08, 0.45, 16),
    new THREE.MeshStandardMaterial({color: '#0058a3', roughness: 0.7})
  );
  leftUpperArm.position.set(-0.48, 1.0, 0);
  leftUpperArm.rotation.z = 0.2;
  leftUpperArm.castShadow = true;
  humanGroup.add(leftUpperArm);
  
  const leftForearm = new THREE.Mesh(
    new THREE.CylinderGeometry(0.07, 0.06, 0.4, 16),
    new THREE.MeshStandardMaterial({color: '#ffdbac', roughness: 0.8})
  );
  leftForearm.position.set(-0.62, 0.65, 0);
  leftForearm.rotation.z = 0.3;
  leftForearm.castShadow = true;
  humanGroup.add(leftForearm);
  
  const leftHand = new THREE.Mesh(
    new THREE.SphereGeometry(0.08, 16, 16),
    new THREE.MeshStandardMaterial({color: '#ffdbac', roughness: 0.8})
  );
  leftHand.position.set(-0.72, 0.42, 0);
  leftHand.scale.set(1, 1.2, 0.7);
  leftHand.castShadow = true;
  humanGroup.add(leftHand);
  
  // Right shoulder and arm
  const rightShoulder = new THREE.Mesh(
    new THREE.SphereGeometry(0.15, 16, 16),
    new THREE.MeshStandardMaterial({color: '#0058a3', roughness: 0.7})
  );
  rightShoulder.position.set(0.4, 1.3, 0);
  rightShoulder.castShadow = true;
  humanGroup.add(rightShoulder);
  
  const rightUpperArm = new THREE.Mesh(
    new THREE.CylinderGeometry(0.09, 0.08, 0.45, 16),
    new THREE.MeshStandardMaterial({color: '#0058a3', roughness: 0.7})
  );
  rightUpperArm.position.set(0.48, 1.0, 0);
  rightUpperArm.rotation.z = -0.2;
  rightUpperArm.castShadow = true;
  humanGroup.add(rightUpperArm);
  
  const rightForearm = new THREE.Mesh(
    new THREE.CylinderGeometry(0.07, 0.06, 0.4, 16),
    new THREE.MeshStandardMaterial({color: '#ffdbac', roughness: 0.8})
  );
  rightForearm.position.set(0.62, 0.65, 0);
  rightForearm.rotation.z = -0.3;
  rightForearm.castShadow = true;
  humanGroup.add(rightForearm);
  
  const rightHand = new THREE.Mesh(
    new THREE.SphereGeometry(0.08, 16, 16),
    new THREE.MeshStandardMaterial({color: '#ffdbac', roughness: 0.8})
  );
  rightHand.position.set(0.72, 0.42, 0);
  rightHand.scale.set(1, 1.2, 0.7);
  rightHand.castShadow = true;
  humanGroup.add(rightHand);
  
  // Waist/Belt
  const belt = new THREE.Mesh(
    new THREE.CylinderGeometry(0.32, 0.33, 0.08, 32),
    new THREE.MeshStandardMaterial({color: '#1a1a1a', roughness: 0.5, metalness: 0.3})
  );
  belt.position.set(0, 0.8, 0);
  humanGroup.add(belt);
  
  // Left leg (more realistic proportions)
  const leftHip = new THREE.Mesh(
    new THREE.SphereGeometry(0.12, 16, 16),
    new THREE.MeshStandardMaterial({color: '#2c3e50', roughness: 0.8})
  );
  leftHip.position.set(-0.12, 0.75, 0);
  leftHip.castShadow = true;
  humanGroup.add(leftHip);
  
  const leftThigh = new THREE.Mesh(
    new THREE.CylinderGeometry(0.11, 0.09, 0.5, 16),
    new THREE.MeshStandardMaterial({color: '#2c3e50', roughness: 0.8})
  );
  leftThigh.position.set(-0.12, 0.45, 0);
  leftThigh.castShadow = true;
  humanGroup.add(leftThigh);
  
  const leftKnee = new THREE.Mesh(
    new THREE.SphereGeometry(0.09, 16, 16),
    new THREE.MeshStandardMaterial({color: '#2c3e50', roughness: 0.8})
  );
  leftKnee.position.set(-0.12, 0.2, 0);
  humanGroup.add(leftKnee);
  
  const leftShin = new THREE.Mesh(
    new THREE.CylinderGeometry(0.08, 0.07, 0.45, 16),
    new THREE.MeshStandardMaterial({color: '#2c3e50', roughness: 0.8})
  );
  leftShin.position.set(-0.13, 0.02, 0.02);
  leftShin.rotation.x = -0.1;
  leftShin.castShadow = true;
  humanGroup.add(leftShin);
  
  const leftFoot = new THREE.Mesh(
    new THREE.BoxGeometry(0.12, 0.08, 0.25),
    new THREE.MeshStandardMaterial({color: '#1a1a1a', roughness: 0.7})
  );
  leftFoot.position.set(-0.13, -0.18, 0.1);
  leftFoot.castShadow = true;
  humanGroup.add(leftFoot);
  
  // Right leg
  const rightHip = new THREE.Mesh(
    new THREE.SphereGeometry(0.12, 16, 16),
    new THREE.MeshStandardMaterial({color: '#2c3e50', roughness: 0.8})
  );
  rightHip.position.set(0.12, 0.75, 0);
  rightHip.castShadow = true;
  humanGroup.add(rightHip);
  
  const rightThigh = new THREE.Mesh(
    new THREE.CylinderGeometry(0.11, 0.09, 0.5, 16),
    new THREE.MeshStandardMaterial({color: '#2c3e50', roughness: 0.8})
  );
  rightThigh.position.set(0.12, 0.45, 0);
  rightThigh.castShadow = true;
  humanGroup.add(rightThigh);
  
  const rightKnee = new THREE.Mesh(
    new THREE.SphereGeometry(0.09, 16, 16),
    new THREE.MeshStandardMaterial({color: '#2c3e50', roughness: 0.8})
  );
  rightKnee.position.set(0.12, 0.2, 0);
  humanGroup.add(rightKnee);
  
  const rightShin = new THREE.Mesh(
    new THREE.CylinderGeometry(0.08, 0.07, 0.45, 16),
    new THREE.MeshStandardMaterial({color: '#2c3e50', roughness: 0.8})
  );
  rightShin.position.set(0.13, 0.02, 0.02);
  rightShin.rotation.x = -0.1;
  rightShin.castShadow = true;
  humanGroup.add(rightShin);
  
  const rightFoot = new THREE.Mesh(
    new THREE.BoxGeometry(0.12, 0.08, 0.25),
    new THREE.MeshStandardMaterial({color: '#1a1a1a', roughness: 0.7})
  );
  rightFoot.position.set(0.13, -0.18, 0.1);
  rightFoot.castShadow = true;
  humanGroup.add(rightFoot);
  
  // IKEA employee badge (more detailed)
  const badgeBack = new THREE.Mesh(
    new THREE.BoxGeometry(0.18, 0.25, 0.02),
    new THREE.MeshStandardMaterial({color: '#ffda1a', roughness: 0.4, metalness: 0.2})
  );
  badgeBack.position.set(0.22, 1.15, 0.13);
  humanGroup.add(badgeBack);
  
  const badgeClip = new THREE.Mesh(
    new THREE.CylinderGeometry(0.02, 0.02, 0.05, 8),
    new THREE.MeshStandardMaterial({color: '#c0c0c0', metalness: 0.8})
  );
  badgeClip.position.set(0.22, 1.27, 0.13);
  badgeClip.rotation.x = Math.PI / 2;
  humanGroup.add(badgeClip);
  
  // Position the human
  humanGroup.position.set(x, y, z);
  scene.add(humanGroup);
  
  // Add label above human
  const labelCanvas = document.createElement('canvas');
  labelCanvas.width = 512;
  labelCanvas.height = 128;
  const labelCtx = labelCanvas.getContext('2d');
  labelCtx.fillStyle = '#0058a3';
  labelCtx.fillRect(0, 0, 512, 128);
  labelCtx.fillStyle = '#ffda1a';
  labelCtx.font = 'bold 60px Arial';
  labelCtx.textAlign = 'center';
  labelCtx.fillText('‚ÑπÔ∏è INFO', 256, 85);
  
  const labelTexture = new THREE.CanvasTexture(labelCanvas);
  const label = new THREE.Mesh(
    new THREE.PlaneGeometry(2, 0.5),
    new THREE.MeshStandardMaterial({map: labelTexture, transparent: true})
  );
  label.position.set(x, y + 2.2, z);
  scene.add(label);
  
  // Make label always face camera
  function updateLabel() {
    label.lookAt(camera.position);
  }
  
  // Clickable invisible box around human
  const infoBox = new THREE.Mesh(
    new THREE.BoxGeometry(1.5, 2.2, 1),
    new THREE.MeshBasicMaterial({visible: false})
  );
  infoBox.position.set(x, y + 1, z);
  infoBox.userData = {name: name, desc: info};
  scene.add(infoBox);
  clickables.push(infoBox);
  
  // Subtle breathing animation
  let breathTime = Math.random() * Math.PI * 2;
  let armTime = Math.random() * Math.PI * 2;
  
  setInterval(() => {
    breathTime += 0.03;
    armTime += 0.02;
    
    // Breathing effect on torso
    torso.scale.z = 1 + Math.sin(breathTime) * 0.02;
    
    // Slight arm movement
    leftUpperArm.rotation.z = 0.2 + Math.sin(armTime) * 0.05;
    rightUpperArm.rotation.z = -0.2 - Math.sin(armTime) * 0.05;
    
    // Head slight movement
    head.rotation.y = Math.sin(armTime * 0.5) * 0.1;
    
    updateLabel();
  }, 50);
  
  return humanGroup;
}

hotspot(0,2,38,'Entry Point','Main entrance. Store maps provided. Peak: 11am-2pm, 5pm-7pm.');
hotspot(-20,2,0,'Showroom Flow','Floor arrows guide customers. Avg 45-60 min in showrooms.');
hotspot(20,2,5,'Product Info','Price tags, codes, QR for catalog. Staff tablets for stock check.');
hotspot(0,2,45,'Marketplace Entry','Natural flow from showroom. Food market adjacent.');
hotspot(45,2,48,'Warehouse Access','Note aisle/bin from tags. Self-service with assistance.');
hotspot(0,2,54,'Exit Process','Queue management. Cart return after payment.');

// Customer path line
const pts=[
  new THREE.Vector3(0,0.1,35),
  new THREE.Vector3(-20,0.1,15),
  new THREE.Vector3(-25,0.1,0),
  new THREE.Vector3(0,0.1,-5),
  new THREE.Vector3(25,0.1,5),
  new THREE.Vector3(20,0.1,25),
  new THREE.Vector3(0,0.1,42),
  new THREE.Vector3(45,0.1,46),
  new THREE.Vector3(0,0.1,54)
];
const pathGeo=new THREE.BufferGeometry().setFromPoints(pts);
const path=new THREE.Line(pathGeo,new THREE.LineBasicMaterial({color:'#ffda1a',linewidth:2}));
scene.add(path);

// Controls
let mouseDown=false,lastX=0,lastY=0;
renderer.domElement.addEventListener('mousedown',e=>{mouseDown=true;lastX=e.clientX;lastY=e.clientY;});
window.addEventListener('mouseup',()=>mouseDown=false);
renderer.domElement.addEventListener('mousemove',e=>{
  if(mouseDown){
    camera.rotation.y-=(e.clientX-lastX)*0.003;
    camera.rotation.x-=(e.clientY-lastY)*0.003;
    camera.rotation.x=Math.max(-Math.PI/3,Math.min(Math.PI/3,camera.rotation.x));
    lastX=e.clientX;lastY=e.clientY;
  }
});

const keys={};
let autoWalk=false;
let walkIndex=0;
const walkPath=[
  {pos:[0,2.5,40],look:[0,2.5,35]},
  {pos:[0,2.5,30],look:[0,2.5,20]},
  {pos:[-10,2.5,20],look:[-20,2.5,15]},
  {pos:[-20,2.5,10],look:[-25,2.5,0]},
  {pos:[-25,2.5,0],look:[-25,2.5,-5]},
  {pos:[-20,2.5,-5],look:[0,2.5,-5]},
  {pos:[0,2.5,-5],look:[20,2.5,0]},
  {pos:[20,2.5,5],look:[25,2.5,5]},
  {pos:[25,2.5,10],look:[20,2.5,20]},
  {pos:[20,2.5,25],look:[10,2.5,25]},
  {pos:[0,2.5,30],look:[0,2.5,40]},
  {pos:[0,2.5,42],look:[20,2.5,45]},
  {pos:[30,2.5,45],look:[45,2.5,48]},
  {pos:[45,2.5,48],look:[45,2.5,50]},
  {pos:[30,2.5,50],look:[0,2.5,52]},
  {pos:[0,2.5,54],look:[0,2.5,56]}
];

window.addEventListener('keydown',e=>{
  keys[e.key.toLowerCase()]=true;
  if(e.key===' '){camera.position.set(0,2.5,40);camera.rotation.set(0,0,0);autoWalk=false;walkIndex=0;}
  if(e.key.toLowerCase()==='t'){autoWalk=!autoWalk;walkIndex=0;}
});
window.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

function smoothMove(from,to,progress){
  return from+(to-from)*progress;
}

function move(){
  if(autoWalk){
    const step=walkPath[walkIndex];
    const nextStep=walkPath[Math.min(walkIndex+1,walkPath.length-1)];
    const speed=0.02;
    
    camera.position.x=smoothMove(camera.position.x,step.pos[0],speed);
    camera.position.y=smoothMove(camera.position.y,step.pos[1],speed);
    camera.position.z=smoothMove(camera.position.z,step.pos[2],speed);
    
    const lookAt=new THREE.Vector3(step.look[0],step.look[1],step.look[2]);
    camera.lookAt(lookAt);
    
    const dist=Math.sqrt(
      Math.pow(camera.position.x-step.pos[0],2)+
      Math.pow(camera.position.z-step.pos[2],2)
    );
    
    if(dist<0.5){
      walkIndex++;
      if(walkIndex>=walkPath.length){
        walkIndex=0;
      }
    }
  }else{
    const speed=keys.shift?0.3:0.15;
    const dir=new THREE.Vector3();
    camera.getWorldDirection(dir);
    dir.y=0;
    dir.normalize();
    const right=new THREE.Vector3().crossVectors(camera.up,dir).normalize();
    if(keys.w)camera.position.addScaledVector(dir,speed);
    if(keys.s)camera.position.addScaledVector(dir,-speed);
    if(keys.a)camera.position.addScaledVector(right,speed);
    if(keys.d)camera.position.addScaledVector(right,-speed);
    camera.position.y=Math.max(1.5,camera.position.y);
  }
}

renderer.domElement.addEventListener('wheel',e=>{
  e.preventDefault();
  camera.fov+=e.deltaY*0.05;
  camera.fov=Math.max(30,Math.min(90,camera.fov));
  camera.updateProjectionMatrix();
});

// Click interaction
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
renderer.domElement.addEventListener('click',e=>{
  const rect=wrap.getBoundingClientRect();
  mouse.x=((e.clientX-rect.left)/rect.width)*2-1;
  mouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const hits=raycaster.intersectObjects(clickables);
  if(hits.length){
    const obj=hits[0].object;
    if(obj.userData.name){
      document.getElementById('title').textContent=obj.userData.name;
      document.getElementById('text').textContent=obj.userData.desc;
      document.getElementById('overlay').style.display='block';
      document.getElementById('backdrop').style.display='block';
    }
  }
});

function closeInfo(){
  document.getElementById('overlay').style.display='none';
  document.getElementById('backdrop').style.display='none';
}

window.addEventListener('resize',()=>{
  camera.aspect=wrap.clientWidth/wrap.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(wrap.clientWidth,wrap.clientHeight);
});

function animate(){
  requestAnimationFrame(animate);
  move();
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>

